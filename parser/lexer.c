/* Generated by re2c 1.0.1 on Fri Jul 26 00:06:48 2019 */
#line 1 "parser/lexer.re"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "parser.h"
#include "includes.h"
#include "../euler/inc/variables.h"
#include "../arch/arm/stm32f746ng/print.h"

#define GETSV(bstr, estr) strndup(estr, bstr - estr)
#define GETFV(bstr, estr) atof(GETSV(bstr, estr))
#define GETIV(bstr, estr) atoi(GETSV(bstr, estr))

float stof(const char *s);
int lex(char *equery);

const char *YYCURSOR;
const char *exsp;
token_info tkn;

static int fch = 0; /* flag to indicate first variable name in the query line */

int lex(char *equery)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat="
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

	const char *YYMARKER, *o1, *o2;

	if (YYCURSOR >= equery) {
		return EOL;
	}
const char *yyt1;
#line 42 "parser/lexer.re"



#line 42 "parser/lexer.c"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
	case '(':	goto yy4;
	case ')':	goto yy6;
	case '*':	goto yy8;
	case '+':	goto yy10;
	case ',':	goto yy12;
	case '-':	goto yy14;
	case '/':	goto yy16;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt1 = YYCURSOR;
		goto yy18;
	case '=':	goto yy21;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
		yyt1 = YYCURSOR;
		goto yy23;
	case 'a':	goto yy26;
	case 'c':	goto yy27;
	case 'e':	goto yy28;
	case 'f':	goto yy29;
	case 'l':	goto yy30;
	case 'm':	goto yy31;
	case 'p':	goto yy32;
	case 'q':	goto yy33;
	case 's':	goto yy34;
	case 't':	goto yy35;
	default:	goto yy2;
	}
yy2:
	++YYCURSOR;
yy3:
#line 78 "parser/lexer.re"
	{ return QUIT; }
#line 113 "parser/lexer.c"
yy4:
	++YYCURSOR;
#line 74 "parser/lexer.re"
	{ return LPAREN;}
#line 118 "parser/lexer.c"
yy6:
	++YYCURSOR;
#line 75 "parser/lexer.re"
	{return RPAREN;}
#line 123 "parser/lexer.c"
yy8:
	++YYCURSOR;
#line 71 "parser/lexer.re"
	{ return MULT; }
#line 128 "parser/lexer.c"
yy10:
	++YYCURSOR;
#line 69 "parser/lexer.re"
	{ return PLUS; }
#line 133 "parser/lexer.c"
yy12:
	++YYCURSOR;
#line 110 "parser/lexer.re"
	{ return COMMA; }
#line 138 "parser/lexer.c"
yy14:
	++YYCURSOR;
#line 70 "parser/lexer.re"
	{ return MINUS;  }
#line 143 "parser/lexer.c"
yy16:
	++YYCURSOR;
#line 72 "parser/lexer.re"
	{ return DIV; }
#line 148 "parser/lexer.c"
yy18:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '.':	goto yy36;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy18;
	default:	goto yy20;
	}
yy20:
	o1 = yyt1;
	o2 = YYCURSOR;
#line 45 "parser/lexer.re"
	{


		sprintf(tkn.name, "%.*s",(int)(o2 - o1));
		tkn.val = stof(tkn.name);
            return INT;
        }
#line 177 "parser/lexer.c"
yy21:
	++YYCURSOR;
#line 73 "parser/lexer.re"
	{ return EQ; }
#line 182 "parser/lexer.c"
yy23:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':	goto yy23;
	default:	goto yy25;
	}
yy25:
	o1 = yyt1;
	o2 = YYCURSOR;
#line 57 "parser/lexer.re"
	{
                sprintf(tkn.name, "%.*s",(int)(o2 - o1));
		if(fch == 0){
			fch = 1;
			strcpy(fvar, tkn.name);
		}
		return VAR;
	}
#line 226 "parser/lexer.c"
yy26:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'b':	goto yy38;
	case 'c':	goto yy39;
	case 's':	goto yy40;
	case 't':	goto yy41;
	default:	goto yy3;
	}
yy27:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'b':	goto yy42;
	case 'e':	goto yy43;
	case 'o':	goto yy44;
	default:	goto yy3;
	}
yy28:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'x':	goto yy45;
	default:	goto yy3;
	}
yy29:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'l':	goto yy46;
	default:	goto yy3;
	}
yy30:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'i':	goto yy47;
	case 'n':	goto yy48;
	case 'o':	goto yy50;
	default:	goto yy3;
	}
yy31:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'o':	goto yy51;
	default:	goto yy3;
	}
yy32:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'i':	goto yy52;
	case 'o':	goto yy54;
	default:	goto yy3;
	}
yy33:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'u':	goto yy55;
	default:	goto yy3;
	}
yy34:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'i':	goto yy56;
	case 'q':	goto yy57;
	default:	goto yy3;
	}
yy35:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'a':	goto yy58;
	default:	goto yy3;
	}
yy36:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy59;
	default:	goto yy37;
	}
yy37:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
	case 0: 	goto yy20;
	case 1: 	goto yy3;
	default:	goto yy61;
	}
yy38:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's':	goto yy62;
	default:	goto yy37;
	}
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy64;
	default:	goto yy37;
	}
yy40:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy65;
	default:	goto yy37;
	}
yy41:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'a':	goto yy66;
	default:	goto yy37;
	}
yy42:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy67;
	default:	goto yy37;
	}
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy68;
	default:	goto yy37;
	}
yy44:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's':	goto yy69;
	case 't':	goto yy71;
	default:	goto yy37;
	}
yy45:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'p':	goto yy73;
	default:	goto yy37;
	}
yy46:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy75;
	default:	goto yy37;
	}
yy47:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's':	goto yy76;
	default:	goto yy37;
	}
yy48:
	++YYCURSOR;
#line 98 "parser/lexer.re"
	{return LN;}
#line 393 "parser/lexer.c"
yy50:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'g':	goto yy77;
	default:	goto yy37;
	}
yy51:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'd':	goto yy79;
	default:	goto yy37;
	}
yy52:
	++YYCURSOR;
#line 114 "parser/lexer.re"
	{return PI;}
#line 410 "parser/lexer.c"
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'w':	goto yy81;
	default:	goto yy37;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy83;
	default:	goto yy37;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy84;
	default:	goto yy37;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy86;
	default:	goto yy37;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy87;
	default:	goto yy37;
	}
yy59:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy59;
	case 'E':
	case 'e':	goto yy89;
	default:	goto yy61;
	}
yy61:
	o1 = yyt1;
	o2 = YYCURSOR;
#line 52 "parser/lexer.re"
	{
		sprintf(tkn.name, "%.*s",(int)(o2 - o1));
		tkn.val = stof(tkn.name);
            return FLOAT;
        }
#line 468 "parser/lexer.c"
yy62:
	++YYCURSOR;
#line 108 "parser/lexer.re"
	{return ABS;}
#line 473 "parser/lexer.c"
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's':	goto yy90;
	default:	goto yy37;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy92;
	default:	goto yy37;
	}
yy66:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy94;
	default:	goto yy37;
	}
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy96;
	default:	goto yy37;
	}
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy98;
	default:	goto yy37;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'h':	goto yy100;
	default:	goto yy70;
	}
yy70:
#line 81 "parser/lexer.re"
	{return COS;}
#line 513 "parser/lexer.c"
yy71:
	++YYCURSOR;
#line 93 "parser/lexer.re"
	{return COT;}
#line 518 "parser/lexer.c"
yy73:
	++YYCURSOR;
#line 96 "parser/lexer.re"
	{return EXP;}
#line 523 "parser/lexer.c"
yy75:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy102;
	default:	goto yy37;
	}
yy76:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy103;
	default:	goto yy37;
	}
yy77:
	++YYCURSOR;
#line 97 "parser/lexer.re"
	{return LOG;}
#line 540 "parser/lexer.c"
yy79:
	++YYCURSOR;
#line 106 "parser/lexer.re"
	{return MOD;}
#line 545 "parser/lexer.c"
yy81:
	++YYCURSOR;
#line 100 "parser/lexer.re"
	{return POW;}
#line 550 "parser/lexer.c"
yy83:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy105;
	default:	goto yy37;
	}
yy84:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'h':	goto yy107;
	default:	goto yy85;
	}
yy85:
#line 85 "parser/lexer.re"
	{return SIN;}
#line 566 "parser/lexer.c"
yy86:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy109;
	default:	goto yy37;
	}
yy87:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'h':	goto yy111;
	default:	goto yy88;
	}
yy88:
#line 89 "parser/lexer.re"
	{return TAN;}
#line 582 "parser/lexer.c"
yy89:
	yych = *++YYCURSOR;
	switch (yych) {
	case '+':
	case '-':	goto yy113;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy114;
	default:	goto yy37;
	}
yy90:
	++YYCURSOR;
#line 82 "parser/lexer.re"
	{return ACOS;}
#line 604 "parser/lexer.c"
yy92:
	++YYCURSOR;
#line 86 "parser/lexer.re"
	{return ASIN;}
#line 609 "parser/lexer.c"
yy94:
	++YYCURSOR;
#line 90 "parser/lexer.re"
	{return ATAN;}
#line 614 "parser/lexer.c"
yy96:
	++YYCURSOR;
#line 102 "parser/lexer.re"
	{return CBRT;}
#line 619 "parser/lexer.c"
yy98:
	++YYCURSOR;
#line 104 "parser/lexer.re"
	{return CEIL;}
#line 624 "parser/lexer.c"
yy100:
	++YYCURSOR;
#line 83 "parser/lexer.re"
	{return COSH;}
#line 629 "parser/lexer.c"
yy102:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy116;
	default:	goto yy37;
	}
yy103:
	++YYCURSOR;
#line 76 "parser/lexer.re"
	{return LIST; }
#line 640 "parser/lexer.c"
yy105:
	++YYCURSOR;
#line 77 "parser/lexer.re"
	{return QUIT;}
#line 645 "parser/lexer.c"
yy107:
	++YYCURSOR;
#line 87 "parser/lexer.re"
	{return SINH;}
#line 650 "parser/lexer.c"
yy109:
	++YYCURSOR;
#line 101 "parser/lexer.re"
	{return SQRT;}
#line 655 "parser/lexer.c"
yy111:
	++YYCURSOR;
#line 91 "parser/lexer.re"
	{return TANH;}
#line 660 "parser/lexer.c"
yy113:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy114;
	default:	goto yy37;
	}
yy114:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy114;
	default:	goto yy61;
	}
yy116:
	++YYCURSOR;
#line 105 "parser/lexer.re"
	{return FLOOR;}
#line 695 "parser/lexer.c"
}
#line 117 "parser/lexer.re"

#pragma GCC diagnostic pop
}

float stof(const char *s)
{
	float rez = 0, fact = 1;
	if (*s == '-') {
		s++;
		fact = -1;
	}
	for (int point_seen = 0; *s; s++) {
		if (*s == '.') {
			point_seen = 1;
			continue;
		}
		int d = *s - '0';
		if (d >= 0 && d <= 9) {
			if (point_seen)
				fact /= 10.0f;
			rez = rez * 10.0f + (float)d;
		}
	}
	return rez * fact;
}

int cmd(char *query)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-function-declaration"
	char *equery;
	void *parser;
	int token = -3;
	char tk[30];
	char *tmp;
	float no;

	parser = (void *)ParseAlloc(malloc);

	equery = (char *)(((char *)query) + strlen(query));
	YYCURSOR = exsp = query;

	while (token != EOL) {
		token = lex(equery);

		//console_puts(tk);
		Parse(parser, token, tkn);
		exsp = YYCURSOR;
	}
	fch = 0;
	tkn.val = 0;
	strcpy(tkn.name, " ");
	token = -3;

	ParseFree(parser, free);
	return (0);
#pragma GCC diagnostic pop
}
